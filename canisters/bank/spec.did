// The asset symbol, e.g. "ICP" or "BTC".
type AssetSymbol = text;
// The internal account id used to identify a account in the
// canister (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
type AccountId = text;
// The internal user id used to identify a user in the
// canister (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
type UserId = text;
// The network id, unique to the canister and associated (e.g. "icp:mainnet").
type NetworkId = text;
// The transfer id which is a UUID (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
type TransferId = text;
// A proposal id which is a UUID (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
type ProposalId = text;
// The notification id which is a UUID (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
type NotificationId = text;
// The timestamp type used in the canister.
type TimestampRFC3339 = text;

// Defines the various states that a notification can be in.
type NotificationStatus = variant {
  // The notification has been sent.
  Sent;
  // The notification has been read by the user.
  Read;
};

// Representsd the different types of notifications within the system.
type NotificationType = variant {
  // Notification for system-wide messages.
  // This can be used for announcements, scheduled maintenance reminders, or other important system messages.
  SystemMessage;
  // Notification for the creation of a new proposal.
  // This should be used to alert users when a new proposal that requires their attention has been created.
  ProposalCreated : record {
    // The proposal id.
    proposal_id : ProposalId;
  };
  // Notification for the creation of a new transfer proposal.
  // This should be used to alert users when a new transfer proposal that requires their attention has been created.
  TransferProposalCreated : record {
    // The proposal id.
    proposal_id : ProposalId;
    transfer_id : TransferId;
    account_id : AccountId;
  };
};

type NotificationTypeInput = variant {
  SystemMessage;
  ProposalCreated;
  TransferProposalCreated;
};

// A record type that can be used to represent a notification.
type Notification = record {
  // The notification id which is a UUID (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
  id : NotificationId;
  // The type of the notification.
  notification_type : NotificationType;
  // The notification status.
  status : NotificationStatus;
  // The user that the notification is for.
  target_user_id : UserId;
  // The notification title.
  title : record {
    // The notification title in the default locale.
    body : text;
    // The locale key that can be used to retrieve the title in the user locale.
    locale_key : text;
  };
  // The notification message.
  message : record {
    // The notification message in the default locale.
    body : text;
    // The locale key that can be used to retrieve the message in the user locale.
    locale_key : text;
  };
  // The time at which the notification was created.
  created_at : TimestampRFC3339;
};

// The input type for getting the list of notifications associated with the caller.
type ListNotificationsInput = record {
  // Show only notifications with the given status.
  status : opt NotificationStatus;
  // The type of the notification (e.g. "system-message").
  notification_type : opt NotificationTypeInput;
  // From which created time to retrieve the notifications.
  from_dt : opt TimestampRFC3339;
  // Until which created time to retrieve the notifications.
  to_dt : opt TimestampRFC3339;
};

// The result type for getting the list of notifications.
type ListNotificationsResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The list of notifications ordered by creation time (newest first).
    notifications : vec Notification;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

type MarkNotificationsReadInput = record {
  // The notifications to mark as read.
  notification_ids : vec NotificationId;
  // If true, all notifications will be marked as read.
  read : bool;
};

type MarkNotificationReadResult = variant {
  Ok;
  Err : Error;
};

// The status of a proposal.
type ProposalStatus = variant { Pending; Adopted; Rejected };

// The status of a proposal.
type ProposalVoteStatus = variant { Pending; Adopted; Rejected; NotRequired };

// A record type that can be used to represent a vote on a proposal.
type ProposalVote = record {
  // The user that has taken the decision.
  user_id : UserId;
  // The user has added to the proposal, once provided it cannot be changed.
  status : ProposalVoteStatus;
  // Optional reason for the vote status.
  status_reason : opt text;
  // The time at which the vote was added.
  decided_at : opt TimestampRFC3339;
};

type ProposalOperationType = variant {
  // A new transfer of funds from a given account.
  Transfer;
};

type ProposalOperation = variant {
  // A new transfer of funds from a given account.
  Transfer : record {
    // The transfer associated with the proposal.
    transfer : Transfer;
    // The account associated with the transfer.
    account : Account;
  };
};

// A record type that can be used to represent a proposed operation in the bank.
type Proposal = record {
  // The proposal id which is a UUID (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
  id : ProposalId;
  // The operation that was proposed.
  operation : ProposalOperation;
  // The user that created the proposal.
  proposed_by : opt UserId;
  // The list of user votes on the proposal.
  votes : vec ProposalVote;
  // The time at which the proposal was created.
  created_at : TimestampRFC3339;
  // The proposal approval status.
  status : ProposalStatus;
  // The metadata associated with the proposal.
  //
  // The metadata is a list of key-value pairs that can be used to store
  // additional information about the proposal.
  metadata : vec record { text; text };
};

// The input type for getting the list of proposals associated with the caller.
type ListProposalsInput = record {
  // Show only proposals with the given status.
  status : opt ProposalStatus;
  // The type of the proposal (e.g. "transfer").
  operation_type : opt ProposalOperationType;
  // From which created time to retrieve the proposals.
  from_dt : opt TimestampRFC3339;
  // Until which created time to retrieve the proposals.
  to_dt : opt TimestampRFC3339;
};

// The result type for getting the list of proposals.
type ListProposalsResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The list of proposals.
    proposals : vec Proposal;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// The input type for getting the list of proposals associated with the account.
type ListAccountProposalsInput = record {
  // The account id to retrieve the proposals from.
  account_id : AccountId;
  // Show only proposals with the given status.
  status : opt ProposalStatus;
  // The type of the proposal (e.g. "transfer").
  operation_type : opt ProposalOperationType;
  // From which created time to retrieve them.
  from_dt : opt TimestampRFC3339;
  // Until which created time to retrieve them.
  to_dt : opt TimestampRFC3339;
};

// The result type for getting the list of proposals for the given account.
type ListAccountProposalsResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The list of proposals.
    proposals : vec Proposal;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Input type for getting a proposal.
type GetProposalInput = record {
  // The proposal id to retrieve.
  proposal_id : ProposalId;
};

// Result type for retrieving a proposal.
type GetProposalResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The proposal that was requested.
    proposal : Proposal;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Input type for voting on a proposal.
type VoteOnProposalInput = record {
  // The proposal id to interact with.
  proposal_id : ProposalId;
  // True if the user approves the proposal, false otherwise.
  approve : opt bool;
  // The reason for the approval or rejection.
  reason : opt text;
};

// Result type for voting on a proposal.
type VoteOnProposalResult = variant {
  Ok : record {
    proposal : Proposal;
  };
  Err : Error;
};

// A record type that can be used to represent a account balance.
type AccountBalanceInfo = record {
  // Balance of the account.
  balance : nat;
  // The number of decimals used by the asset (e.g. `8` for `BTC`, `18` for `ETH`, etc.).
  decimals : nat32;
  // The time at which the balance was last updated.
  last_update_timestamp : TimestampRFC3339;
};

// Result type for listing all accounts.
type ListAccountResult = variant {
  Ok : record {
    // The list of accounts.
    accounts : vec Account;
  };
  Err : Error;
};

type ListAccountTransfersInput = record {
  // The account id to retrieve.
  account_id : AccountId;
  // The transfer status in text format (e.g. "pending", "approved", etc.).
  status : opt text;
  // From which date to retrieve the transfers.
  from_dt : opt TimestampRFC3339;
  // Until which date to retrieve the transfers.
  to_dt : opt TimestampRFC3339;
};

type TransferListItem = record {
  // The transfer id.
  transfer_id : TransferId;
  // The destination address of the transaction (e.g. "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2").
  to : text;
  // The amount to transfer.
  amount : nat;
  // The status of the transfer.
  status : TransferStatus;
  // The time at which the transfer was created.
  created_at : TimestampRFC3339;
};

type ListAccountTransfersResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The list of transfers.
    transfers : vec TransferListItem;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// The role of an user in the Bank.
type UserRole = variant {
  // The user is an admin of the bank.
  Admin;
  // Any authenticated user has this role.
  User;
  // The guest role is also used to allow access when the user does not have the user defined.
  Guest;
};

// A record type that can be used to represent a user in the bank.
type User = record {
  // The UUID of the user (e.g. "d0cf5b3f-7017-4cb8-9dcf-52619c42a7b0").
  id : UserId;
  // The principals associated with the user.
  identities : vec principal;
  // The unconfirmed principals associated with the user.
  unconfirmed_identities : vec principal;
  // The role of the user.
  access_roles : vec UserRole;
  // The time at which the user was created or last modified (e.g. "2021-01-01T00:00:00Z").
  last_modification_timestamp : TimestampRFC3339;
};

// A record type that can be used to represent the bank permissions.
type BankPermission = record {
  // The permission identified (e.g. "create-account").
  permission_id : text;
  // The list of roles that have the permission.
  access_roles : vec UserRole;
};

// The blockchain network to used in a transaction.
type Network = record {
  // The network id, unique to the canister and associated (e.g. "icp:mainnet").
  id : NetworkId;
  // The name of the network (e.g. "Mainnet").
  name : text;
};

// Tranders can have additional information attached to them,
// this type can be used to represent the additional info.
type TransferMetadata = record {
  // The key of the additional info (e.g. "nonce",  "tag", "memo", etc...)
  key : text;
  // The value of the additional info (e.g. "0x1234" or "my-tag")
  value : text;
};

// The status of a transfer.
type TransferStatus = variant {
  // The transfer is pending approval.
  Pending;
  // The transfer has been approved.
  Approved;
  // The transfer has been rejected.
  Rejected : record {
    // The reason for the rejection.
    reason : text;
  };
  // The transfer has been failed.
  Failed : record {
    // The failure reason.
    reason : text;
  };
  // The transfer has been cancelled by the initiator.
  //
  // This can happen if the initiator cancels the transfer before it is approved.
  Cancelled : record {
    // The reason for the cancellation.
    reason : opt text;
  };
  // The transfer has been submitted for execution.
  Submitted;
  // The transfer is being processed.
  Processing : record {
    // The time at which the transfer started being processed.
    started_at : TimestampRFC3339;
  };
  // The transfer has been completed.
  //
  // For natively supported tokens this means that the transaction has
  // submitted to the blockchain. For non natively supported tokens this means
  // that the transaction has been signed and can be submitted by the client.
  Completed : record {
    // Time at which the transaction was completed.
    completed_at : TimestampRFC3339;
    // The transaction hash, if available.
    hash : opt text;
    // The base64 encoded value of the signed transaction, if available.
    signature : opt text;
  };
};

// A record type that can be used to represent a transfer in a given account.
type Transfer = record {
  // The internal transfer id, this a unique identifier for the transfer.
  id : TransferId;
  // The account id to use for the transfer.
  from_account_id : AccountId;
  // The destination address of the transaction (e.g. "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2").
  to : text;
  // The fee to pay for the transaction, if applicable.
  fee : nat;
  // The amount to transfer.
  amount : nat;
  // The status of the transfer.
  status : TransferStatus;
  // The transfer is only executed if all the policies are fulfilled before the `expiration_dt`.
  expiration_dt : TimestampRFC3339;
  // When the transaction should be executed.
  execution_plan : TransferExecutionSchedule;
  // The network used when submitting the transaction to the blockchain.
  network : Network;
  // Transfers can be tagged with optional additional info (e.g. a `nonce` for Ethereum transactions).
  metadata : vec TransferMetadata;
};

// The schedule for executing a transaction of a given transfer.
type TransferExecutionSchedule = variant {
  // The transaction will be executed immediately.
  Immediate;
  // The transaction will be executed at a given time.
  Scheduled : record {
    // The time at which the transaction will be executed,
    // it must be in the future.
    execution_time : TimestampRFC3339;
  };
};

// Input type for transferring funds.
type TransferInput = record {
  // The account id to use for the transaction.
  from_account_id : AccountId;
  // The amount to transfer.
  amount : nat;
  // The destination address of the transaction (e.g. "1BvBMSE...").
  to : text;
  // The transaction will not be created if the transfer
  // was not approved until the `expiration_dt`.
  //
  // If not set, the system will use the default expiration time.
  expiration_dt : opt TimestampRFC3339;
  // When the transaction should be executed.
  //
  // If not set, the default option used by the system is `Immediate`.
  execution_plan : opt TransferExecutionSchedule;
  // The fee to pay for the transaction, if applicable.
  //
  // If not set, the default fee will be used.
  fee : opt nat;
  // The network to use for the transaction, if not the
  // default network of the account will be used.
  network : opt Network;
  // Trasanctions can be tagged with an optional additional info
  // (e.g. a nonce in the case of an Ethereum transaction)
  metadata : opt vec TransferMetadata;
};

// Result type for transferring funds.
type TransferResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The transfer that was created.
    transfer : Transfer;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

type GetTransferInput = record {
  // The transfer id to retrieve.
  transfer_id : TransferId;
};

type GetTransferResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The transfer that was retrieved.
    transfer : Transfer;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

type GetTransfersInput = record {
  // The list of transfer ids to retrieve.
  transfer_ids : vec TransferId;
};

type GetTransfersResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The transfer that was retrieved.
    transfers : vec Transfer;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Generic error type added to responses that can fail.
type Error = record {
  // Error code, added as a string to allow for custom error codes.
  code : text;
  // Error message to be displayed to the user.
  message : opt text;
  // Error details to be displayed to the user.
  details : opt vec record { text; text };
};

// A record type that can be used to represent a account in the canister.
type Account = record {
  // The internal account id.
  id : AccountId;
  // The blockchain identifier (e.g., `ethereum`, `bitcoin`, `icp`, etc.)
  blockchain : text;
  // The asset symbol, e.g. "ICP" or "BTC".
  symbol : AssetSymbol;
  // The asset standard that is supported (e.g. `erc20`, etc.), canonically represented as a lowercase string
  // with spaces replaced with underscores.
  standard : text;
  // The address of the account (e.g. "0x1234").
  address : text;
  // The number of decimals used by the asset (e.g. `8` for `BTC`, `18` for `ETH`, etc.).
  decimals : nat32;
  // A friendly name for the account.
  name : opt text;
  // If the list is empty, the bank owners are the only owners.
  owners : vec UserId;
  // Account balance when available.
  balance : opt AccountBalanceInfo;
  // The policies that can be used to control the account.
  //
  // If the list is empty but there are policies globally defined for the bank,
  // the global policies will be used.
  policies : vec AccountPolicy;
  // Metadata associated with the account (e.g. `{"contract": "0x1234", "symbol": "ANY"}`).
  metadata : vec record { text; text };
  // The time at which the account was created or last modified (e.g. "2021-01-01T00:00:00Z").
  last_modification_timestamp : TimestampRFC3339;
};

type ApprovalThresholdPolicy = variant {
  // The percentage of approvals required for a transaction to be executed.
  //
  // The value must be between 0 and 100.
  VariableThreshold : nat8;

  // The number of approvals required for a transaction to be executed.
  //
  // If there are less owners than the threshold, the number of owners will be used.
  FixedThreshold : nat8;
};

// The policies that can be used to control the account.
type AccountPolicy = variant { approval_threshold : ApprovalThresholdPolicy };

// Input type for creating a account.
type CreateAccountInput = record {
  // The blockchain identifier (e.g., `ethereum`, `bitcoin`, `icp`, etc.)
  blockchain : text;
  // The asset standard that is supported (e.g. `native`, `erc20`, etc.), canonically represented as a lowercase string
  // with spaces replaced with underscores.
  standard : text;
  // The list of owners of the account.
  //
  // If the list is empty, the caller will be the only owner.
  owners : vec UserId;
  // The policies that can be used to control the account.
  policies : vec AccountPolicy;
  // A friendly name for the account (e.g. "My Account").
  name : opt text;
  // Metadata associated with the account (e.g. `{"contract": "0x1234", "symbol": "ANY"}`).
  metadata : opt vec record { text; text };
};

// Result type for creating a account.
type CreateAccountResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The account that was created.
    account : Account;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Input type for getting a account.
type GetAccountInput = record {
  // The account id to retrieve.
  account_id : AccountId;
};

// Result type for getting a account.
type GetAccountResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The account that was retrieved.
    account : Account;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

type AccountBalance = record {
  // The account id.
  account_id : AccountId;
  // The balance of the account.
  balance : nat;
  // The number of decimals used by the asset (e.g. `8` for `BTC`, `18` for `ETH`, etc.).
  decimals : nat32;
  // The time at which the balance was last updated.
  last_update_timestamp : TimestampRFC3339;
};

// Input type for getting a account balance.
type FetchAccountBalancesInput = record {
  // The account ids to retrieve.
  account_ids : vec AccountId;
};

// Result type for getting a account.
type FetchAccountBalancesResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The account balance that was retrieved.
    balances : vec AccountBalance;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// A record type that can be used to represent an asset in the bank.
type BankAsset = record {
  // The blockchain identifier (e.g., `ethereum`, `bitcoin`, `icp`, etc.)
  blockchain : text;
  // The asset symbol, e.g. "ICP" or "BTC".
  symbol : AssetSymbol;
  // The asset standard that is supported (e.g. `erc20`, etc.), canonically represented as a lowercase string
  // with spaces replaced with underscores.
  //
  // If empty, then only the native blockchain asset is supported.
  standards : vec text;
  // The asset name (e.g. `Internet Computer`, `Bitcoin`, `Ethereum`, etc.)
  name : text;
  // The asset metadata (e.g. `{"logo": "https://example.com/logo.png"}`),
  // also, in the case of non-native assets, it can contain other required
  // information (e.g. `{"address": "0x1234"}`).
  metadata : vec record { text; text };
};

// A record type that can be used to represent the bank features.
type BankFeatures = record {
  // The list of supported assets.
  supported_assets : vec BankAsset;
};

// Result type for getting the bank feature details.
type GetFeaturesResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The bank features.
    features : BankFeatures;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// The settings of the bank.
type BankSettings = record {
  // The list of admin users associated with the bank.
  owners : vec User;
  // The percentage of approvals required for a bank proposal to be
  // executed (e.g. upgrade the canister).
  //
  // Only admin users are considered for the approval threshold.
  //
  // The value must be between 0 and 100.
  approval_threshold : nat8;
  // The list of permissions that are applied to the bank.
  permissions : vec BankPermission;
  // The time at which the bank was last upgraded.
  last_upgrade_timestamp : TimestampRFC3339;
};

// Input type for retrieving a user.
type GetUserInput = record {
  // The user id to retrieve, if not set the caller user will be used if available.
  user_id : opt UserId;
};

// Result type for retrieving a user.
type GetUserResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The user that was retrieved.
    user : User;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Input type for registering a user.
type RegisterUserInput = record {
  // The principals associated with the user.
  identities : vec principal;
};

// Result type for registering an user.
type RegisterUserResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The user that was registered.
    user : User;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Input type for editing a user.
type EditUserInput = record {
  // The user id to update.
  user_id : UserId;
  // The principals associated with the user.
  identities : opt vec principal;
};

// Result type for editing an user.
type EditUserResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The user that was updated.
    user : User;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Input type for confirming an user and its associated identity.
type ConfirmUserIdentityInput = record {
  // The user id to confirm.
  user_id : UserId;
};

// Result type for confirming a user and its associated identity.
type ConfirmUserIdentityResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The user that was confirmed.
    user : User;
  };
  // The error that occurred (e.g. the user does not have the necessary access rights).
  Err : Error;
};

// Result type for getting the bank settings.
type BankSettingsResult = variant {
  // The result data for a successful execution.
  Ok : record {
    // The bank settings.
    settings : BankSettings;
  };
  // The error that occurred (e.g. the caller is not an admin).
  Err : Error;
};

// The init configuration for the bank.
type BankInit = record {
  // The list of admin principals to be associated with the bank.
  owners : opt vec principal;
  // The percentage of approvals required for a bank proposal to be
  // executed (e.g. upgrade the canister).
  //
  // Only admin users are considered for the approval threshold.
  //
  // The value must be between 0 and 100.
  approval_threshold : opt nat8;
  // The list of permissions that are applied to the bank.
  permissions : opt vec BankPermission;
};

// The Bank service definition.
service : (opt BankInit) -> {
  // Get the bank features (e.g. supported assets).
  //
  // Required permission: "read:features"
  features : () -> (GetFeaturesResult) query;
  // Get the list of notifications associated with the caller.
  //
  // Required permission: "read:notification"
  list_notifications : (input : ListNotificationsInput) -> (ListNotificationsResult) query;
  // Mark the notifications as read.
  //
  // Required permission: "write:notification"
  mark_notifications_read : (input : MarkNotificationsReadInput) -> (MarkNotificationReadResult);
  // Create a new account.
  //
  // Required permission: "write:account"
  create_account : (input : CreateAccountInput) -> (CreateAccountResult);
  // Get a account by id.
  //
  // If the caller does not have access to the account, an error will be returned.
  //
  // Required permission: "read:account"
  get_account : (input : GetAccountInput) -> (GetAccountResult) query;
  // Get the account balance.
  //
  // If the caller does not have access to the account, an error will be returned.
  //
  // Required permission: "read:account"
  fetch_account_balances : (input : FetchAccountBalancesInput) -> (FetchAccountBalancesResult);
  // List all accounts that the caller has access to.
  //
  // If the caller is not the owner of any account, an error will be returned.
  //
  // Required permission: "read:account"
  list_accounts : () -> (ListAccountResult) query;
  // List all transfers from the requested account.
  //
  // Required permission: "read:transfer"
  list_account_transfers : (input : ListAccountTransfersInput) -> (ListAccountTransfersResult) query;
  // Transfer funds from a selected account, this action will only create a new transaction
  // if the account policies have been sucessfully fulfilled.
  //
  // If the caller does not have access to the account, an error will be returned.
  //
  // Required permission: "write:transfer"
  transfer : (input : TransferInput) -> (TransferResult);
  // Get a transfer by id.
  //
  // If the caller does not have access to the transfer, an error will be returned.
  //
  // Required permission: "read:transfer"
  get_transfer : (input : GetTransferInput) -> (GetTransferResult) query;
  // Get transfers by their ids.
  //
  // Required permission: "read:transfer"
  get_transfers : (input : GetTransfersInput) -> (GetTransfersResult) query;
  // Get the list of proposals.
  //
  // Required permission: "read:proposal"
  list_proposals : (input : ListProposalsInput) -> (ListProposalsResult) query;
  // Get the list of proposals for a given account.
  //
  // Required permission: "read:proposal"
  list_account_proposals : (input : ListAccountProposalsInput) -> (ListAccountProposalsResult) query;
  // Get the proposal by id.
  //
  // Required permission: "read:proposal"
  get_proposal : (input : GetProposalInput) -> (GetProposalResult) query;
  // Record the vote of the user on the proposal.
  //
  // Required permission: "write:proposal"
  vote_on_proposal : (input : VoteOnProposalInput) -> (VoteOnProposalResult);
  // Register a user in the bank.
  //
  // Required permission: "write:register-user"
  register_user : (input : RegisterUserInput) -> (RegisterUserResult);
  // Confirm that the caller owns the user.
  //
  // Required permission: "write:register-user"
  confirm_user_identity : (input : ConfirmUserIdentityInput) -> (ConfirmUserIdentityResult);
  // Edit the provided bank user.
  //
  // Required permission: "write:user"
  edit_user : (input : EditUserInput) -> (EditUserResult);
  // Get the user associated with the caller or the user id provided.
  //
  // Required permission: "read:user"
  get_user : (input : GetUserInput) -> (GetUserResult) query;
  // Get the bank settings.
  //
  // Required permission: "admin"
  bank_settings : () -> (BankSettingsResult) query;
};
