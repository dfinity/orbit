import { execSync } from 'child_process';
import { createCommand } from 'commander';
import { writeFile } from 'fs/promises';
import { releaseVersion } from 'nx/release';
import { isAbsolute, join } from 'path';
import { getCurrentReleaseId, parseArgsListSplitByComma } from '../utils';

const parsePreReleaseMode = (releaseMode?: string): 'alpha' | 'beta' | 'rc' | 'prod' => {
  if (!releaseMode) {
    return 'prod';
  }

  switch (releaseMode) {
    case 'alpha':
      return 'alpha';
    case 'beta':
      return 'beta';
    case 'rc':
      return 'rc';
    default:
      throw new Error(`Invalid pre-release mode: ${releaseMode}`);
  }
};

const command = createCommand('prepare').description(
  'Handles versioning of projects and generating the changelogs.',
);

command
  .option(
    '-p, --projects <VALUE>',
    'The projects to include in the release, separated by commas. If not provided, all projects will be included.',
    parseArgsListSplitByComma,
  )
  .option('-d, --dry-run', 'Whether or not to perform a dry-run of the release process')
  .option('-v, --verbose', 'Whether or not to log verbose output')
  .option(
    '-P, --pre-release <VALUE>',
    'Specify the type of pre-release version to use (alpha, beta or rc)',
    parsePreReleaseMode,
  )
  .option(
    '-o, --release-output <TYPE>',
    'Specify where the version information of the release should be stored',
    '.release.json',
  );

command.action(async options => {
  const releaseMode = !options.preRelease ? 'prod' : options.preRelease;

  const { projectsVersionData } = await releaseVersion({
    firstRelease: true,
    dryRun: options.dryRun,
    verbose: options.verbose,
    projects: options.projects,
    specifier: releaseMode !== 'prod' ? 'prerelease' : undefined,
    preid: releaseMode !== 'prod' ? options.preRelease : undefined,
  });

  if (!options.dryRun) {
    const newVersions = Object.values(projectsVersionData).filter(data => data.newVersion != null);
    if (newVersions.length === 0) {
      console.log('No new versions to commit.');

      return;
    }

    const stagedFiles = execSync('git diff --cached --name-only').toString().trim();

    if (!stagedFiles) {
      console.log('No staged changes to commit.');

      return;
    }

    const releaseOutputPath = isAbsolute(options.releaseOutput)
      ? options.releaseOutput
      : join(__dirname, '../../..', options.releaseOutput);

    const nextReleaseId = getCurrentReleaseId() + 1;

    console.log(`Writing release information to ${releaseOutputPath}`);

    await writeFile(
      releaseOutputPath,
      JSON.stringify(
        {
          __important__: 'DO NOT MODIFY THIS FILE. This file is automatically generated.',
          releaseId: nextReleaseId,
          projectsVersionData: projectsVersionData,
        },
        null,
        2,
      ),
    );

    execSync(`git add ${releaseOutputPath}`);

    console.log('Staged changes detected, committing...');
    // Commit the staged changes
    const commitMessage = 'chore(release): bump versions and prepare release';
    execSync(`git commit -m "${commitMessage}"`).toString().trim();
  }
});

export default command;
